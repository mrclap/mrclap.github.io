---
layout: post
title: DB
categories:
  - overall 
# feature_image: ""
tags: 컴퓨터과학, DB, 데이터페이스
---
> 데이터베이스, [한재엽님의 Part 1-5 데이터베이스](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database)를 기반으로 여러분들의 블로그를 참조!

# 데이터베이스
### 데이터베이스
#### 데이터베이스를 사용하는 이유
기존의 파일 시스템을 이용한 데이터 관리의 경우
- 데이터 종속성
- 데이터 중복성
- 데이터 무결성
의 문제가 존재

##### 데이터베이스의 특징
1. 데이터 독립성
 - 물리적 독립성 : 데이터베이스의 사이즈를 늘리거나, 성능향상을 위한 데이터 파일 증가 및 신규 추가에도 응용프로그램을 수정할 필요가 없음
 - 논리적 독립성 : 데이터베이스는 논리적 구조를 통해 다양한 응용 프로그램의 논리적 요구 충족 가능

2. 데이터 무결성
 - 여러 경로를 통해 잘못된 데이터가 발생하는 경우를 방지, 데이터 유효성 검새를 통해 데이터 무결성 구현

3. 데이터 보안성
 - 인가된 사용자만을 접근허용하도록 계정 및 접근 권한 관리

4. 데이터의 일관성
 - 연관된 정보를 논리적 구조로 관리하여 데이텨 변경에 따른 데이터 불일치성을 배제
 - 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우 배제

5. 데이터 중복 최소화
 - 데이터 통합 관리를 통해 자료의 중복문제 해결

** [무결성(Integrity)와 일관성(consistency)의 차이에 관한 stackoverflow](https://stackoverflow.com/questions/4882692/are-there-any-difference-between-data-integrity-and-data-consistency)


#### 데이터베이스의 성능
- 데이터베이스의 성능 이슈는 디스크I/O 시간의 단축과 직결 
- 보통 순차 I/O가 랜덤 I/O보다 빠름
- DB 쿼리 튜닝을 통해 랜덤 I/O를 줄이는 것이 중요

<br> 

### Index
#### 인덱스(Index)란 무엇인가?
- DBMS에서 테이블의 모든 데이터를 검색하여 결과를 가져온다면 시간이 오래 걸림
- 따라서, 칼럼의 값과 해당 레코드가 저장된 주소를 키-값의 쌍으로 인덱스를 만들어 둠
- DBMS의 인덱스는 항상 정렬된 상태를 유지하므로 원하는 값을 탐색하는 경우에는 빠르지만, 새로운 값을 추가하거나, 삭제, 수정하는 경우에는 느림
- 즉, DBMS에서 인덱스는 데이터의 저장 성능을 희생하여 데이터의 읽기 속도를 높임
- 너무 많은 컬럼을 인덱스로 생성시 데이터 저장 성능이 떨어지며, 인덱스의 크기가 비대해져 역효과가 생김

#### Index 자료구조
#### B+-Tree 인덱스 알고리즘
- 일반적으로 사용되는 알고리즘
- 칼럼의 값을 변경하지 않고 원래의 값을 이용해 인덱싱
- ***자세한 내용은 추후 필요시 공부..***

#### Hash 인덱스 알고리즘
- 칼럼의 값으로 해시 값을 계산하여 인덱싱(매우 빠른 검색)
- 값의 일부만으로 인덱싱 검색이 불가
- 메모리 기반의 데이터 베이스에서 사용

#### index 생성에 b-tree를 사용하는 이유
- 부등호 연산을 포함한 검색기능의 지원을 위함

#### Primary Index vs Secondary Index
- 인덱스에서 클러스터드는 비슷한 것들을 묶어 저장하는 형태인데 주로 비슷한 값을 동시에 조회하는 경우가 많음에 착안한 것임
  - 비슷한 값이란 물리적으로 인접한 장소에 저장된 데이터
- 클러스터드 인덱스는 테이블의 프라이머리 키에 대해서 적용되는 것으로, 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터드 인덱스라 칭함
  - 클러스터드 인덱스에서는 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되며, 프라이머리 키값이 변경되면, 물리적 위치 또현 변경
- 클러스터드 인덱스는 테이블 당 한 개만 생성이 가능(프라이머리 키에 의해 적용되기 때문)
- 다만 non 클러스터드 인덱스는 테이블에 여러개 생성 가능

#### Composite Index
- 인덱스로 설정하는 필드의 속성이 중요
- title, author의 순서로 인덱스 설정시, title검색은 index효과를 보지만, author만을 검색하는 경우에는 효과 없음

#### Index의 성능과 고려사항
- Index생성 시 Insert, Delete, Update쿼리 실행 시 별도의 과정이 추가로 수행되므로 무분별한 인덱싱이 좋은 것은 아님
- 컬럼을 이루고 있는 데이터의 형식에 따라 인덱스의 성능이 다르므로 데이터 형식에 따라 선택적으로 인덱싱 필요
  - `이름`, `나이`, `성별` 세 가지 필드를 갖고 있는 테이블에 대해서는
  - `이름`에 대해서만 인덱싱 하는 것이 가장 효율 적임
  - 나이와 성별과 같은 값은 range가 적어 의미가 없으며, 필요시에는 bitmap index를 사용

  





