---
layout: post
title: OS
categories:
  - overall 
# feature_image: ""
tags: 컴퓨터과학, OS, 운영체제
---
> 운영체제, [한재엽님의 Part 1-4 OS](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS)를 기반으로 여러분들의 블로그를 참조!

# 운영체제
### 프로세스와 스레드의 차이
#### 프로세스(Process)
- 프로세스는 실행중인 프로그램
- 디스크에서 메모리에 적재되어 CPU의 할당을 받을 수 있음
- OS로부터 주소 공간, 파일, 메모리 등을 할당 받게 됨
- 구성요소
  - 프로세스 스택 : 함수의 매개변수 / 복귀 주소 / 로컬 변수
  - 데이터 섹션 : 전역 변수
  - 메모리 힙 : 프로세스 실행 중 동적으로 할당되는 메모리

##### 프로세스 제어 블록(Process Control Block, PCB)
- 특정 프로세스에 중요한 정보를 저장하고 있는 운영체제의 자료구조
- 운영체제는 프로세스의 관리를 위해 프로세스의 생성과 동시에 고유한 PCB 생성
- 프로세스는 CPU를 할당 받아작업을 처리하다가 프로세스의 전환이 발생할 경우 진행하던 작업을 저장하고 CPU의 반환이 필요
  - 작업의 진행 상황을 PCB에 저장
- PCB에 저장되는 정보
  - 프로세스 식별자(Process ID, PID) : 프로세스 식별번호
  - 프로세스 상태 : new, ready, running, waiting, terminated 등의 상태 저장
  - 프로그램 카운터 : 프로세스가 다음에 실행할 명령어의 주소
  - CPU 레지스터
  - CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등
  - 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보 포함
  - 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록
  - 어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호 등

#### 스레드(Thread)
- 프로세스의 실행 단위
- 한 프로세스 내에서 동작되는 여러 실행 흐름
  - 프로세스 내의 주소 공간이나 자원의 공유 가능
- 구성
  - 스레드 ID
  - 프로그램 카운터
  - 레지스터 집합
  - 스택
- 공유자원(다른 스레드와)
  - 코드
  - 데이터 섹션
  - 운영체제 자원(열린 파일, 신호 등)
- 멀티스레딩
  - 하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유
  - 자원의 생성과 관리의 중복성을 최소화함으로써 수행 능력 향상

##### 스택이 스레드마다 존재하는 이유
- 스택은 [함수 호출 시 전달되는 인자, 되돌아갈 주소값, 함수 내 선언 변수]에 사용
- 따라서 스택을 독립적으로 사용하면 독립적인 함수의 사용 가능
- 스택은 즉 독립적인 실행 흐름을 위한 최소 조건

##### PC Register를 스레드마다 독립할당하는 이유
- 프로세서 레지스터는 명령이 어디까지 수행됐는지를 저장
- 스레드는 CPU를 할당 받았다가 스케줄러에 의해 우선순위를 빼앗길 수 있음
- 다 수행되지 못한 명령어에 대해서 위치를 표시할 필요 존재

<br/>

### 멀티스레드
#### 장점
- 프로세스를 이용하여 동시에 처리하던 일을 스레드로 구현할 경우 메모리 공간과 시스템 자원 소모를 줄일 수 있음
- 스레드간 통신은 **전역 변수의 공간**이나 **heap영역**을 이용하므로 별도의 자원을 사용하지 않음(프로세스간 통신에 비해 훨씬 간단)
- 스레드의 context switch는 프로세스 context switch와 다르게 **캐시 메모리**를 유지

#### 단점
- 동일한 자원에 접근하는 경우에 대한 처리 필요
  - 동기화 작업 필요
  - 작업 순서 컨트롤, 자원 접근 컨트롤 필요
  - 하지만 위 작업들에 의해 병목현상이 발생할 가능성 존재

#### 멀티스레드 vs 멀티프로세스
- 멀티스레드가 멀티프로세스보다 적은 메모리 공간 사용 / context swtich 빠름
- 오류에 의해 하나 스레드 종료가 전체 스레드에 영향을 끼칠 가능성 존재


<br/>

### 스케줄러
프로세스의 스케줄링을 위한 Queue 
- Job Queue : 현재 시스템 내의 모든 프로세스 집합
- Ready Queue : 현재 메모리 내에 있으며, CPU를 점유하여 실행을 대기하는 프로세스 집합
- Device Queue : Device I/O 작업을 대기하는 프로세스 집합

각 Queue를 프로세스들에 넣고 빼는 스케줄러

#### 장기스케줄러(Long-term scheduler or job scheduler)
- 한정된 메모리에 많은 프로세스가 한꺼번에 메모리에 올라올 경우, 대용량 메모리(일반적인 디스크)에 임시 저장
- 이 pool에 저장되어 있는 프로세스 중 어떤 프로세스에 메모리를 할당하여 Ready Queue로 보낼지 결정
- 메모리 <-> 디스크 사이의 스케줄링 담당
- 프로세스에 memory를 할당
- Degree of Multiprogramming 제어(메모리에 몇 개의 프로그램이 올라갈지)
- 프로세스 상태 (new / ready)
cf) 메모리에 프로그램이 너무 많거나 적게 올라가도 성능이 좋지 않음. **time sharing system에서는 장기 스케줄러가 존재하지 않음** 곧바로 메모리에 올라가서 ready 상태가 됨

#### 단기스케줄러(Short-term scheduler or CPU scheduler)
- CPU와 메모리 사이의 스케줄링 담당
- Ready Queue에 존재하는 프로세스 중 어떤 프로세스를 running할지 결정
- 프로세스에 CPU를 할당(scheduler dispatch)
- 프로세스의 상태(ready -> running -> waiting -> ready)

#### 중기스케줄러(Medium-term scheduler or Swapper)
- 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄(swapping)
- 프로세스에게서 memory를 deallocate
- degree of Multiprogramming 제어
- 현 시스템에서 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절
- 프로세스 상태(ready -> )

##### 
- 외부적 이유로 프로세스 수행이 정지된 상태로 메모리에서 내려간 상태를 의미
- 프로세스 전부가 디스크로 swap out
- blocked 상태는 다른 I/O 작업을 기다리는 상태이므로 ready state로 돌아갈 수 있지만 는 불가능

<br/>

### CPU 스케줄러
스케줄링 대상은 Ready Queue에 있는 프로세스들

#### FCFS(First Come First Served)
##### 특징
- 비선점형(Non-Preemptive) 스케줄링
   - CPU 점유시 CPU burst가 완료될때까지 CPU를 반환하지 않음
- 할당되었던 CPU반환시에 스케줄링 이루어짐

##### 문제점
- convoy effect : 소요시간이 긴 프로세스가 먼저 도달하여 효율성이 낮아지는 현상 발생


#### SJF(Shortest - Job - First)
##### 특징
- 프로세스의 진입순서보다 CPU burst time이 짧은 프로세스를 먼저 CPU에 할당
- 비선점형(Non-Preemptive) 스케줄링

##### 문제점
- starvation : 지나친 효율성 추구로 프로세스가 차별을 받게 됨 / 상대적으로 사용 시간이 긴 프로세스가 할당을 받지 못하는 상황 발생


#### SRT(Shortest Remaining time First)
##### 특징
- 새로운 프로세스 도착시 스케줄링
- 선점형(Preemptive) 스케줄링 
  - 수행중인 프로세스의 남은 burst time보다 더 짧은 CPU Burst time을 가지는 프로세스 도착시 CPU 빼앗김

##### 문제점
- starvation : 새로운 프로세스 도달시마다 스케줄링을 다시 함 / CPU burst time(CPU 사용시간)측정 불가


#### Priority Scheduling
##### 특징
- 우선순위가 가장 높은 프로세스에게 CPU 할당
- 우선순위는 정수로표현, 작은숫자가 우선
- 선점형 스케줄링(Preemptive) 방식
  - 더 높은 우선순위의 프로세스 도착시 실행중인 프로세스를 멈추고 CPU 선점
- 비선점형 스케줄링(Non-Premmptive) 방식
  - 더 높은 우선순위의 프로세스 도착시 Ready Queue의 가장 앞에 넣음

##### 문제점
- starvation : 무기한 봉쇄(Indefinite blocking) - 실행 준비는 되었으나 CPU를 사용하지 못하는 프로세스들이 CPU를 무기한 대기


#### Round Robin
##### 특징
- 현대적 CPU 스케줄링
- 각 프로세스는 동일한 크기의 할당 시간(time quantum) 가짐
- 할당 시간이 지나면 프로세스는 ready queue의 뒤에서 다시 대기
- Round Robin은 CPU사용시간이 랜덤한 프로세스들이 섞여 있으 경우에 효율적임
- Round Robin이 가능한 이유는 **Process의 context를 save할 수 있기 때문**

##### 장점
- Response time이 빨라짐
  - ready queue에 있는 n개의 프로세스에 대해 각각 q의 할당 시간을 준다면 프로세스는 q 단위로 CPU시간의 1/n을 얻음
  - 즉 모든 프로세스는 (n-1)q time unit 이상 기다리지 않음
- 프로세스가 기다리는 시간이 CPU를 사용하는 만큼 증가

##### 주의점
- 설정한 time quantum(q)가 너무 커지게되면 FCFS와 동일
- 너무 작아질경우 잦은 context switch로 overhead 발생


<br/>

